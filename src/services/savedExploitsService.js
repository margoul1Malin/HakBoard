// Service pour gérer les exploits sauvegardés
import { v4 as uuidv4 } from 'uuid';

// Clé pour le stockage local
const SAVED_EXPLOITS_KEY = 'saved_exploits';

// Récupérer tous les exploits sauvegardés
export const getSavedExploits = () => {
  try {
    const savedExploitsJson = localStorage.getItem(SAVED_EXPLOITS_KEY);
    if (!savedExploitsJson) {
      return [];
    }
    return JSON.parse(savedExploitsJson);
  } catch (error) {
    console.error('Erreur lors de la récupération des exploits sauvegardés:', error);
    return [];
  }
};

// Sauvegarder un exploit
export const saveExploit = (exploit) => {
  try {
    const savedExploits = getSavedExploits();
    
    // Vérifier si l'exploit existe déjà
    const existingIndex = savedExploits.findIndex(e => e.id === exploit.id);
    
    if (existingIndex >= 0) {
      // Mettre à jour l'exploit existant
      savedExploits[existingIndex] = {
        ...exploit,
        savedAt: new Date().toISOString(),
        notes: savedExploits[existingIndex].notes || ''
      };
    } else {
      // Ajouter un nouvel exploit
      savedExploits.push({
        ...exploit,
        savedId: uuidv4(), // ID unique pour la sauvegarde
        savedAt: new Date().toISOString(),
        notes: ''
      });
    }
    
    localStorage.setItem(SAVED_EXPLOITS_KEY, JSON.stringify(savedExploits));
    return true;
  } catch (error) {
    console.error('Erreur lors de la sauvegarde de l\'exploit:', error);
    return false;
  }
};

// Supprimer un exploit sauvegardé
export const deleteSavedExploit = (savedId) => {
  try {
    const savedExploits = getSavedExploits();
    const updatedExploits = savedExploits.filter(e => e.savedId !== savedId);
    
    localStorage.setItem(SAVED_EXPLOITS_KEY, JSON.stringify(updatedExploits));
    return true;
  } catch (error) {
    console.error('Erreur lors de la suppression de l\'exploit sauvegardé:', error);
    return false;
  }
};

// Mettre à jour les notes d'un exploit sauvegardé
export const updateExploitNotes = (savedId, notes) => {
  try {
    const savedExploits = getSavedExploits();
    const exploitIndex = savedExploits.findIndex(e => e.savedId === savedId);
    
    if (exploitIndex >= 0) {
      savedExploits[exploitIndex].notes = notes;
      localStorage.setItem(SAVED_EXPLOITS_KEY, JSON.stringify(savedExploits));
      return true;
    }
    
    return false;
  } catch (error) {
    console.error('Erreur lors de la mise à jour des notes:', error);
    return false;
  }
};

// Vérifier si un exploit est déjà sauvegardé
export const isExploitSaved = (exploitId) => {
  try {
    const savedExploits = getSavedExploits();
    return savedExploits.some(e => e.id === exploitId);
  } catch (error) {
    console.error('Erreur lors de la vérification de l\'exploit sauvegardé:', error);
    return false;
  }
};

// Exporter les fonctions du service
export const savedExploitsService = {
  getSavedExploits,
  saveExploit,
  deleteSavedExploit,
  updateExploitNotes,
  isExploitSaved
}; 
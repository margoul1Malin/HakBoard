// Service pour interagir avec Exploit-DB
import { v4 as uuidv4 } from 'uuid';

// URLs pour accéder aux données d'Exploit-DB
const EXPLOITDB_FILES_URL = 'https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv';
const EXPLOITDB_BASE_URL = 'https://www.exploit-db.com/exploits/';
const EXPLOITDB_RAW_URL = 'https://gitlab.com/exploit-database/exploitdb/-/raw/main/';

// Fonction pour télécharger et parser les exploits
const fetchExploits = async () => {
  console.log('Téléchargement des exploits depuis Exploit-DB...');
  
  try {
    // Télécharger le fichier CSV
    const response = await fetch(EXPLOITDB_FILES_URL);
    
    if (!response.ok) {
      throw new Error(`Erreur HTTP: ${response.status}`);
    }
    
    const csvText = await response.text();
    
    // Parser le CSV
    const exploits = parseExploitsCsv(csvText);
    
    console.log(`${exploits.length} exploits téléchargés`);
    return exploits;
  } catch (error) {
    console.error('Erreur lors du téléchargement des exploits:', error);
    throw error;
  }
};

// Fonction pour parser le CSV d'Exploit-DB
const parseExploitsCsv = (csvText) => {
  const lines = csvText.split('\n');
  const headers = lines[0].split(',');
  
  // Indices des colonnes importantes
  const idIndex = headers.indexOf('id');
  const fileIndex = headers.indexOf('file');
  const descriptionIndex = headers.indexOf('description');
  const dateIndex = headers.indexOf('date');
  const authorIndex = headers.indexOf('author');
  const typeIndex = headers.indexOf('type');
  const platformIndex = headers.indexOf('platform');
  const portIndex = headers.indexOf('port');
  const verifiedIndex = headers.indexOf('verified');
  
  // Parser chaque ligne
  const exploits = [];
  
  for (let i = 1; i < lines.length; i++) {
    if (!lines[i].trim()) continue;
    
    // Gérer correctement les virgules dans les champs entre guillemets
    const values = parseCSVLine(lines[i]);
    
    if (values.length >= headers.length) {
      const exploit = {
        id: values[idIndex],
        edbUrl: `${EXPLOITDB_BASE_URL}${values[idIndex]}`,
        file: values[fileIndex],
        title: values[descriptionIndex],
        description: values[descriptionIndex],
        date: values[dateIndex],
        author: values[authorIndex],
        type: values[typeIndex].toLowerCase(),
        platform: values[platformIndex],
        port: values[portIndex],
        verified: values[verifiedIndex] === '1',
        tags: extractTags(values[descriptionIndex], values[typeIndex])
      };
      
      // Extraire le CVE s'il existe
      const cveMatch = exploit.title.match(/CVE-\d{4}-\d+/i);
      exploit.cve = cveMatch ? cveMatch[0] : '';
      
      exploits.push(exploit);
    }
  }
  
  return exploits;
};

// Fonction pour extraire les tags à partir de la description et du type
const extractTags = (description, type) => {
  const tags = [];
  
  // Ajouter le type comme tag
  if (type) {
    tags.push(type);
  }
  
  // Extraire les technologies/frameworks mentionnés
  const technologies = [
    'WordPress', 'Joomla', 'Drupal', 'PHP', 'SQL', 'XSS', 'CSRF',
    'Buffer Overflow', 'RCE', 'LFI', 'RFI', 'XXE', 'SSRF', 'Apache',
    'Nginx', 'IIS', 'Windows', 'Linux', 'macOS', 'iOS', 'Android'
  ];
  
  technologies.forEach(tech => {
    if (description.includes(tech)) {
      tags.push(tech);
    }
  });
  
  // Extraire les types d'attaques
  if (description.toLowerCase().includes('injection')) tags.push('Injection');
  if (description.toLowerCase().includes('traversal')) tags.push('Traversal');
  if (description.toLowerCase().includes('bypass')) tags.push('Bypass');
  
  return [...new Set(tags)]; // Éliminer les doublons
};

// Fonction pour parser correctement une ligne CSV (gère les champs entre guillemets)
const parseCSVLine = (line) => {
  const result = [];
  let current = '';
  let inQuotes = false;
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    
    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === ',' && !inQuotes) {
      result.push(current);
      current = '';
    } else {
      current += char;
    }
  }
  
  result.push(current); // Ajouter le dernier champ
  return result;
};

// Fonction pour rechercher des exploits
export const searchExploits = async (searchTerm, filters = {}) => {
  console.log('Recherche d\'exploits pour:', searchTerm, 'avec filtres:', filters);
  
  try {
    // Récupérer tous les exploits directement depuis Exploit-DB
    const allExploits = await fetchExploits();
    
    // Filtrer les résultats en fonction du terme de recherche
    let results = allExploits.filter(exploit => {
      const searchLower = searchTerm.toLowerCase();
      return (
        exploit.title.toLowerCase().includes(searchLower) ||
        exploit.description.toLowerCase().includes(searchLower) ||
        (exploit.cve && exploit.cve.toLowerCase().includes(searchLower)) ||
        exploit.author.toLowerCase().includes(searchLower) ||
        exploit.platform.toLowerCase().includes(searchLower)
      );
    });
    
    // Appliquer des filtres supplémentaires si spécifiés
    if (filters.type && filters.type !== '') {
      results = results.filter(exploit => exploit.type === filters.type);
    }
    
    if (filters.platform && filters.platform !== '') {
      results = results.filter(exploit => 
        exploit.platform.toLowerCase().includes(filters.platform.toLowerCase())
      );
    }
    
    if (filters.verified !== undefined) {
      results = results.filter(exploit => exploit.verified === filters.verified);
    }
    
    // Limiter les résultats pour éviter de surcharger l'interface
    const limitedResults = results.slice(0, 100);
    
    return {
      success: true,
      data: limitedResults,
      count: results.length,
      totalCount: allExploits.length,
      message: `${results.length} exploits trouvés pour "${searchTerm}" (affichage des 100 premiers)`
    };
  } catch (error) {
    console.error('Erreur lors de la recherche d\'exploits:', error);
    return {
      success: false,
      data: [],
      count: 0,
      message: 'Erreur lors de la recherche d\'exploits: ' + error.message
    };
  }
};

// Fonction pour obtenir les détails d'un exploit
export const getExploitDetails = async (exploitId) => {
  console.log('Récupération des détails de l\'exploit:', exploitId);
  
  try {
    // Récupérer tous les exploits
    const allExploits = await fetchExploits();
    
    // Trouver l'exploit correspondant
    const exploit = allExploits.find(e => e.id === exploitId);
    
    if (!exploit) {
      return {
        success: false,
        data: null,
        message: `Exploit avec ID ${exploitId} non trouvé`
      };
    }
    
    // Récupérer le code de l'exploit si disponible
    let code = null;
    try {
      if (exploit.file) {
        const fileUrl = `${EXPLOITDB_RAW_URL}${exploit.file}`;
        console.log('Téléchargement du code depuis:', fileUrl);
        
        const response = await fetch(fileUrl);
        
        if (response.ok) {
          code = await response.text();
          console.log('Code récupéré avec succès');
        } else {
          console.error('Erreur lors de la récupération du code:', response.status);
        }
      }
    } catch (codeError) {
      console.error('Erreur lors de la récupération du code de l\'exploit:', codeError);
    }
    
    // Enrichir l'exploit avec des informations supplémentaires
    const enrichedExploit = {
      ...exploit,
      code: code,
      references: [
        exploit.cve ? `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${exploit.cve}` : null,
        exploit.cve ? `https://nvd.nist.gov/vuln/detail/${exploit.cve}` : null,
        exploit.edbUrl
      ].filter(Boolean) // Supprimer les valeurs null
    };
    
    return {
      success: true,
      data: enrichedExploit,
      message: 'Détails de l\'exploit récupérés avec succès'
    };
  } catch (error) {
    console.error('Erreur lors de la récupération des détails de l\'exploit:', error);
    return {
      success: false,
      data: null,
      message: 'Erreur lors de la récupération des détails de l\'exploit: ' + error.message
    };
  }
};

// Exporter les fonctions du service
export const exploitDbService = {
  searchExploits,
  getExploitDetails
}; 